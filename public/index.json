[{"categories":["方向"],"content":"[证明、论证与零知识] Proofs, Arguments, and Zero-Knowledge.pdf Why and How zk-SNARK Works Definitive Explanation.pdf 简洁非交互零知识证明综述.pdf ","date":"2024-03-28","objectID":"/zkp%E8%B5%84%E6%96%99%E7%9B%AE%E5%BD%95.html:0:0","tags":["笔记","笔记1"],"title":"ZKP资料目录","uri":"/zkp%E8%B5%84%E6%96%99%E7%9B%AE%E5%BD%95.html"},{"categories":["方向"],"content":"连接GitHub ","date":"2024-03-28","objectID":"/%E8%BF%9E%E6%8E%A5github.html:0:0","tags":["笔记","笔记1"],"title":"连接GitHub","uri":"/%E8%BF%9E%E6%8E%A5github.html"},{"categories":["方向"],"content":"HTTP 访问不了主要是DNS被污染了，在本机DNS即可。打开如下文件将下面的内容后缀在文件中即可，修改需要管理员权限，确保自己真的修改成功了C:\\Windows\\System32\\drivers\\etc\\hosts​。在 CMD 窗口输入：ipconfig /flushdns​ 下面的内容可以在下面的网站中找到最新的： hosts · frankwuzp/github-host - Gitee.com maxiaof/github-hosts: 通过修改Hosts解决国内Github经常抽风访问不到,每日更新 #Github Hosts Start #Project Address: https://github.com/maxiaof/github-hosts #Update URL: https://raw.githubusercontent.com/maxiaof/github-hosts/master/hosts 151.101.129.194 github.global.ssl.fastly.net 185.199.109.153 assets-cdn.github.com 185.199.108.153 documentcloud.github.com 140.82.112.3 gist.github.com 185.199.109.133 gist.githubusercontent.com 185.199.108.154 github.githubassets.com 140.82.112.18 help.github.com 140.82.114.9 nodeload.github.com 185.199.109.133 raw.github.com 140.82.112.17 status.github.com 185.199.111.153 training.github.com 185.199.109.133 avatars.githubusercontent.com 185.199.109.133 avatars0.githubusercontent.com 185.199.109.133 avatars1.githubusercontent.com 185.199.108.133 avatars2.githubusercontent.com 185.199.111.133 avatars3.githubusercontent.com 185.199.110.133 avatars4.githubusercontent.com 185.199.111.133 avatars5.githubusercontent.com 185.199.109.133 avatars6.githubusercontent.com 185.199.109.133 avatars7.githubusercontent.com 185.199.111.133 avatars8.githubusercontent.com 185.199.109.133 favicons.githubusercontent.com 140.82.114.9 codeload.github.com 52.217.116.57 github-cloud.s3.amazonaws.com 52.216.48.177 github-com.s3.amazonaws.com 3.5.25.27 github-production-release-asset-2e65be.s3.amazonaws.com 52.216.221.89 github-production-user-asset-6210df.s3.amazonaws.com 3.5.29.126 github-production-repository-file-5c1aeb.s3.amazonaws.com 185.199.111.153 githubstatus.com 140.82.114.18 github.community 185.199.110.133 media.githubusercontent.com 185.199.109.133 camo.githubusercontent.com 185.199.110.133 raw.githubusercontent.com 185.199.109.133 cloud.githubusercontent.com 185.199.110.133 user-images.githubusercontent.com 2606:50c0:8003::153 customer-stories-feed.github.com 185.199.108.153 pages.github.com 140.82.112.5 api.github.com 140.82.114.26 live.github.com 140.82.112.30 githubapp.com 140.82.113.3 github.com 52.224.38.193 github.dev 140.82.112.21 central.github.com 140.82.113.25 alive.github.com 185.199.111.133 desktop.githubusercontent.com #Github Hosts End ","date":"2024-03-28","objectID":"/%E8%BF%9E%E6%8E%A5github.html:1:0","tags":["笔记","笔记1"],"title":"连接GitHub","uri":"/%E8%BF%9E%E6%8E%A5github.html"},{"categories":["方向"],"content":"SSH 命令行中输入如下指令。 ssh-keygen -t rsa -C \"your_email@example.com\" #github注册账号的邮箱，其他的不知道可不可以 去用户目录（C:\\Users\\用户）下找到.ssh目录，没有该目录，设置显示隐藏目录，在.ssh目录下找到id_rsa.pub，前往GitHub，创建一个SSH keys，把id_rsa.pub复制过来就可以。 ​​ 将下面内容添加到.ssh/config中,如果没有可以自己创建一个。 Host github.com User git Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 在cmd中输入，验证。 ssh -T git@github.com ‍ ‍ ","date":"2024-03-28","objectID":"/%E8%BF%9E%E6%8E%A5github.html:2:0","tags":["笔记","笔记1"],"title":"连接GitHub","uri":"/%E8%BF%9E%E6%8E%A5github.html"},{"categories":["算法"],"content":"NTT（快速数论变换） ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:0:0","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"1 算法介绍 ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:1:0","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"1.1 多项式乘法引入 1.1.1 多项式的两种表示方法 一般 $n$ 次多项式如公式（1）所示。多项式具有两种表示方法分别是系数表示法和点值表示法。 $$\r\\begin{equation}\rA(x)=a_0+a_1x^1+a_2x^2+\\ldots +a_{n-1}x^{n-1}+a_nx^n=\\sum^{n}_{i=0}a_ix^i\r\\end{equation}\r$$\r系数表示法： 任意多项式都可以通过一组系数所确定，而这组系数所组成的向量也叫做系数向量,通过系数向量表示一个多项的方式也叫做系数表示法。例如公式（1）中 $A(x)$ 的系数向量为：$\\mathbf{a}=[a_0 ,a_1,\\ldots,a_{n-1},a_n]$。 点值表示法： 对于一个已知的多项式例如公式（1）中的 $A(x)$ ，将 $x_i$ 代进去可以得到一个确定的值 $y_i$ ，如：$y_0=A(x_0)$ 。且可将 $(x_0,y_0)$ 看作是坐标系上的一个点。可将任意多（互不相等）的自变量 $( x_1,x_2,\\ldots,x_{n-1}, x_n)$ 代入到 $A(x)$ 中，从而得到更多的点：$(x_1,y_1),(x_2,y_2),\\ldots(x_n,y_n)$。通过 n+1 个不同点组成的点集 $P={(x_0,y_0),(x_1,y_1),\\ldots,(x_n,y_n)} $ ，唯一确定一个 n 次多项式，该方式也叫做多项式的点值表示法。 1.1.2 多项式乘法 已知两个多项式 $A(x)$ 和 $B(x)$，分别是 $n$ 次多项式和 m 次多项式。 $$\r\\begin{align}\rA(x)=\\sum^{n}_{i=0}a_ix^i\\\\\rB(x)=\\sum^{m}_{i=0}b_ix^i\r\\end{align}\r$$\r公式（2）和公式（3）相乘得到一个最高为 $n+m$ 次的多项式 $C(x)$。系数向量：$\\mathbf{c}=[c_0 ,c_1,\\ldots,c_{m+n}]$。 $$\r\\begin{align}\rC(x)=\\sum^{n+m}_{i=0}c_ix^i\r\\end{align}\r$$\r系数乘法： 系数乘法，将两个多项式的系数相乘，系数相乘，如公式（5）所示。不难看出时间复杂为 $O(n^2)$。整理可得公式（6）。 $$\r\\begin{align}\rC_{i+j}= \\sum_{i=0}^{n} \\sum_{j=0}^{m} a_i b_j \\end{align}\r$$\r$$\r\\begin{align}\rC_i=\\sum^{i}_{j=0}a_jb_{i-j}\r\\end{align}\r$$\r点值乘法： 点值乘法只需将要将对应的纵坐标相乘即可，但是因为新得到的多项式次数更高，所以每个因子多项式都需要提供 $m+n+1$ 个点参与运算。时间复杂度为 $O(n)$。 小结 在计算多项式乘法时，点值表示的时间复杂度低。但是在计算系统中系数表示更加的常用。于是很自然的想到，在进行乘法时从系数表示转换到点值表示，使用点值表示法进行乘法运算，然后再转换为系数表示法。 但是很不幸的是，从系数表示转换到点值表示，以及点值表示到系数表示，这两个过程的时间复杂度均为 $O(n^2)$。 图1 多项式乘法总结图\r1.1.3 转换优化 如果通过减少求值的点数可以较少计算时间。根据函数的奇偶性我们可以只求一半的点值，从而减少一半的计算量。这里为了方便表示设一个 $n-1$ 次的一般多项式，$n=2^a , a\\in \\N$。 $$\rP(x)=p_0+p_1x^1+p_2x^2+\\ldots +p_{n-1}x^{n-1}=\\sum^{n-1}_{i=0}p_ix^i\r$$\r将偶次项和奇数项分别组合： $$\rP(x)=(p_0+p_2x^2\\ldots+p_{n-2}x^{n-2})+(p_1x^1+\\ldots +p_{n-1}x^{n-1})\r$$\r对奇次项提取公因式 $x$: $$\rP(x)=(p_0+p_2x^2\\ldots+p_{n-2}x^{n-2})+x(p_1x^0+\\ldots +p_{n-1}x^{n-2})\r$$\r化简为： $$\r\\begin{align}\rP(x)=P_e(x^2)+xP_o(x^2)\r\\end{align}\r$$\r则我们可以取 $\\frac{n}{2}$ 对相反数点，这样我们只需要计算一半的点值。 $$\rP(x_i)=P_e(x_i^2)+xP_o(x_i^2) \\\\\rP(-x_i)=P_e(x_i^2)-x_iP_o(x_i^2)\r$$\r观察公式（7）不难发现，是将是将 $P(x)$ 拆成了两个规模为 $\\frac{n}{2}$ 的 $P_e(x)$,$P_o(x）$。自然而然想到了递归执行。但是问题是相反数平方运算后所得结果均为正数，无法构造相反数对，无法实现递归。如果能一直保持相反数点对，那么时间复杂度可以表示为 $T$$($​**$n$$)$​$=$$T$​$($$2$​$n)$$+$​$O$$($​$n$**$)$，即时间复杂度为 $O(n\\log n)$。 1.1.4 单位根（复平面） 既然实数域没有办法解决上面的问题，可以将起扩展到复平面。我们希望取一些点使其平方后的结果依然存在相反数对。 图2 复平面图\r既然点是我们自己选的，那不如使最后一组相反数点对为 ${1,-1}$。我们取 n 等于 8 作为演示。不难看出最后选取的 8 个点均是 $x^8=1$ 的解。 图3 n=8选点示例图\r对于任意 $n=2^a , a\\in \\N$，来说即为 $x^n=1$。 由欧拉公式: $$\re^{i \\theta}=\\cos\\theta+i\\sin\\theta\r$$\r可以得到公式： $$\rz^n=1=\\cos2k\\pi+i\\sin2k\\pi=e^{2k\\pi i},k \\in[ 0,n)\r$$\r所以: $$\rz=\\sqrt[n]{e^{2k\\pi i}}=e^\\frac{2k\\pi i}{n} ,k \\in[ 0,n)\r$$\r上面是 $n$ 次单位复数根的推导。当 $k=1$ 时，值 $\\omega_n=e^\\frac{2\\pi i}{n}$ 被成为主 $n$ 次单位复数根，其他的 $n$ 次单位根都是 $\\omega_n$ 的幂次。其中 $\\theta$ 表示为复平面单位圆上的弧长。因此 $e^\\frac{2\\pi i}{n}$ 表示将一个单位圆均分 $n$ 份。$n=8$ 时如下图所示。 图4 8次单位根示意图\r$n$ 次单位根的性质： 消去引理： $$\r\\omega_{dn}^{dk}=\\omega_n^k\\\\\r\\omega_{n}^{\\frac{n}{2}}=-\\omega_2=-1\\\\\r\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_n^k\r$$\r折半引理： $$\r(\\omega_n^k)^2=\\omega_{\\frac{n}{2}}^k\r$$\r求和引理： $$\r\\sum_{i=0}^{n-1} (\\omega_n^k)^i =\r\\begin{cases}\r0, \u0026 k \\neq mn, \\ m \\in \\mathbb{Z} \\\\\rn, \u0026 k = mn, \\ m \\in \\mathbb{Z}\r\\end{cases}\r$$\r","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:1:1","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"1.2 $DFT$ 与 $IDFT$ 经过 1.1 节的介绍已经对多项式乘法的相关内容有了相应的了解，下面开始正式介绍 $DFT$ 与 $IDFT$，将在 1.3 节介绍 $FFT$ 与 $IFFT$ 的相关内容。我们是从多项式乘法引入的$DFT$和$IDFT$，但是$DFT$和$IDFT$的应用的场景有很多，多项式求值、大数乘法，拉格朗日插值、矩阵乘法、中国剩余定理以及环同态。 1.2.1 离散傅里叶变换（$DFT$） 设有一个 $n-1$ 次的多项式 $P(x)$: $$\rP(x) = a_0 + a_1x + a_2x^2 + \\ldots + a_{n-1}x^{n-1}\r$$\r多项式 $P(x)$ 的 $DFT$ 在单位根 $\\omega_n^k = e^{2\\pi i k / n} $ 上的值计算如下： $$\rP_k = P(\\omega_n^k) = \\sum_{j=0}^{n-1} a_j \\omega_n^{kj} \\quad k = 0, 1, \\ldots, n-1\r$$\r1.2.2 逆离散傅里叶变换（$IDFT$） 对 $DFT$ 过程我们可以通过矩阵进行描述 $y=Wa$： $$\r\\left[ \\begin{array}{c}\ry_0 \\\\\ry_1 \\\\\ry_2 \\\\\r\\vdots \\\\\ry_{n-1} \\\\\r\\end{array} \\right]\r=\r\\left[ \\begin{array}{cccc}\r1 \u0026 1 \u0026 \\ldots \u0026 1 \\\\\r1 \u0026 \\omega_n \u0026 \\ldots \u0026 \\omega_n^{n-1} \\\\\r1 \u0026 \\omega_n^2 \u0026 \\ldots \u0026 \\omega_n^{2(n-1)} \\\\\r\\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\r1 \u0026 \\omega_n^{n-1} \u0026 \\ldots \u0026 \\omega_n^{(n-1)^2}\r\\end{array} \\right]\r\\left[ \\begin{array}{c}\ra_0 \\\\\ra_1 \\\\\ra_2 \\\\\r\\vdots \\\\\ra_{n-1} \\\\\r\\end{array} \\right]\r$$\r其中 $V_n$ 是一个范德蒙矩阵，是一个可逆矩阵，因此 $IDFT$：$a=W^{-1}y$。 下面求取:$W_n^{-1}$。矩阵 $W$ 可以表示为：$W_{jk}=ω_ n^{jk}$。$W_{jk}^{-1}$ 的值应该是 $W_{jk}$ 的共轭除以 $n$。由 $\\omega _n$ 的性质，我们知道 $\\omega _n^k$ 的共轭是 $\\omega _n^{-k}$。因此 $W_{jk}^{-1}=\\frac{1}{n}ω_ n^{-jk}$。所以 $DFT$ 和 $IDFT$ 的时间复杂一致，甚至计算流程基本一致。 $$\ra_j= \\frac{1}{n}\\sum_{j=0}^{n-1} y_j ω_ n^{-jk} \\quad k = 0, 1, \\ldots, n-1\r$$\r","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:1:2","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"1.3 快速傅里叶变化（$FFT$） 其实 $FFT$ 的思路在 1.1.3 节中进行了介绍只是并不是很完善，下面进行一个较为细致的描述。详细介绍 FFT 的递归实现和迭代实现。 1.3.1 $FFT$ 递归实现 将单位根带入公式（7）得： $$\r\\begin{align}\rP(\\omega_n^k)=P_e((\\omega_n^k)^2)+{\\omega_n^k}P_o((\\omega_n^k)^2) \\quad k \\in[ 0,n)\r\\end{align}\r$$\r根据消去引理推导出得对称性以及折半引理对公式（8）进行化简。取 $k \\in[0,\\frac{n}{2})$ 。 $$\r\\begin{align*}\rP(\\omega_{n}^{k})\u0026=P_{e}((\\omega_{n}^{k})^2)+{\\omega_{n}^{k}}P_{o}((\\omega_{n}^{k})^2)\\\\\r\u0026 =P_{e}(\\omega_{\\frac{n}{2}}^{k})+{\\omega_{n}^{k}}P_{o}(\\omega_{\\frac{n}{2}}^{k})\\\\ \\end{align*}\r$$\r$$\r\\begin{align*}\rP(\\omega_{n}^{k+m})\u0026=P_{e}((\\omega_{n}^{k+m})^2)+\\omega_{n}^{k+m}P_{o}((\\omega_{n}^{k+m})^2)\\\\\r\u0026 =P_{e}(\\omega_{\\frac{n}{2}}^{k+m})+\\omega_{n}^{k+m}P_{o}(\\omega_{\\frac{n}{2}}^{k+m})\\\\ \u0026 =P_{e}(-\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}P_{o}(-\\omega_{\\frac{n}{2}}^{k})\\\\\r\u0026 =P_{e}(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}P_{o}(\\omega_{\\frac{n}{2}}^{k})\r\\end{align*}\r$$\r即公式（9-10），这两个式子也被称为 CT(Cooley-Tukey)蝶形操作，$\\omega_{n}^{k}$ 被成为转换因子。 $$\r\\begin{align}\rP(\\omega_{n}^{k})=P_{e}(\\omega_{\\frac{n}{2}}^{k})+{\\omega_{n}^{k}}P_{o}(\\omega_{\\frac{n}{2}}^{k})\\\\\rP(\\omega_{n}^{k+m})=P_{e}(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}P_{o}(\\omega_{\\frac{n}{2}}^{k})\r\\end{align}\r$$\r现在给出递归版本得算法： $$\r\\begin{array}{ll}\r\\hline\r\\text{\\textbf{Algorithm 1}} \u0026 \\text{ Recursion FFT}\\\\ \\hline\r\\textbf{Require:} \u0026 P=[p_0,p_1,\\ldots,p_{n-1}]\\quad n=2^{a},a\\in\\mathbb{N}\\\\ \\text{\\textbf{function}} \u0026 \\text{FFT\\_R}(P)\\\\ \u0026n\\leftarrow len(P)\\\\\r\u0026\\text{if}\\quad n==1 \\\\\r\u0026\\quad \\text{return}\\quad P\\\\\r\u0026\\text{endif}\\\\\r\u0026\\omega_n \\leftarrow e^{\\frac{2\\pi i}{n}}\\\\\r\u0026P_e\\leftarrow [p_0,p_2,\\ldots,p_{n-2}]\\\\\r\u0026P_o\\leftarrow [p_1,p_3,\\ldots,p_{n-1}]\\\\\r\u0026y_e\\leftarrow FFT\\_R(P_e)\\\\\r\u0026y_o\\leftarrow FFT\\_R(P_o)\\\\\r\u0026 \\text{for} \\quad k \\quad \\text{to} \\quad \\frac{n}{2}-1\\\\\r\u0026\\quad y[k]=y_e[k]+\\omega_n^ky_o[k]\\\\\r\u0026\\quad y[k+\\frac{n}{2}]=y_e[k]-\\omega_n^ky_o[k]\\\\\r\u0026\\text{endfor}\\\\\r\u0026\\text{return} \\quad y \\\\\r\\textbf{end function} \u0026 \\\\ \\hline \u0026 \\end{array}\r$$\r蝶形操作： 蝶形操作得名于其数据流图的形状，上面的推导过程出现的是 CT 蝶形变换，还有一种 GS 蝶形变换。 图5 CT蝶形操作图\r图6 CT蝶形操作简化图\r通过公式（9-10）我们可以推导出 GS 蝶形变换的形式。将公式（9）和（10）分别加减运算得： $$\rP(\\omega_{n}^{k}) + P(\\omega_{n}^{k+m}) = 2P_{e}(\\omega_{\\frac{n}{2}}^{k})\r\\\\\rP(\\omega_{n}^{k}) - P(\\omega_{n}^{k+m}) = 2\\omega_{n}^{k}P_{o}(\\omega_{\\frac{n}{2}}^{k})\r$$\r整理得公式（11-12）不难看出，GS 操作是 CT 操作的逆过程，可以用于 $IFFT$ 中,当然也可以用在$FFT$中，通常CT方法也叫$DIT$（时域抽取）操作，GS操作也叫$DIF$（频域抽取）操作。 $$\r\\begin{align}\rP_e(\\omega_{\\frac{n}{2}}^{k}) \u0026= \\frac{1}{2}(P(\\omega_{n}^{k}) + P(\\omega_{n}^{k+m})) \\\\\rP_o(\\omega_{\\frac{n}{2}}^{k}) \u0026= \\frac{1}{2\\omega_{n}^{k}}(P(\\omega_{n}^{k}) - P(\\omega_{n}^{k+m})) \\end{align}\r$$\r图7 GS蝶形操作\r1.3.2 $FFT$ 迭代实现 继续优化。依然拿 n=8 举例。递归数据操作如图 7 所示，在递归操作中是自定向下层层展开，然后逐层向上收缩。每一次递归都会消耗堆栈资源，影响效率。如果可以从底向上计算，那么可以省去堆栈资源的消耗，提高程序运行效率。于是现在的问题就变为了如何确定递归树叶子节点的元素排序。 图8 n=8时递归示意图\r位逆序 将叶子节点元素顺序和原始元素顺序均使用二进制表示。发现二进制表示发生了左右对称反转，称之为位逆序变换。 //位逆序 Layer 4: 0 4 2 6 1 5 3 7 Binary: 000 100 010 110 001 101 011 111 Reverse: 000 001 010 011 100 101 110 111 Decimal: 0 1 2 3 4 5 6 7 下面是 Bit-Reverse-Copy 的实现: $$\r\\begin{array}{ll}\\hline\\text{\\textbf{Algorithm 2}} \u0026 \\text{Bit-Reverse-Copy}\\\\ \\hline\\text{\\textbf{Require:}} \u0026 A\\\\ \\text{\\textbf{function}} \u0026 \\text{BitReverseCopy}(A)\\\\ \u0026 n\\leftarrow len(A)\\\\ \u0026 b\\leftarrow\\log_2(n)\\\\ \u0026 \\text{for}\\quad i=0\\quad\\text{to}\\quad n-1\\\\ \u0026 \\quad r\\leftarrow\\text{ReverseBits}(i,b)\\\\ \u0026 \\quad B[r]\\leftarrow A[i]\\\\ \u0026 \\text{endfor}\\\\ \u0026 \\text{return}\\quad B\\\\ \\text{\\textbf{end function}} \u0026 \\phantom{}\\\\ \\hline \u0026 \\phantom{}\\end{array}\r$$\r函数 ReverseBits 的实现如下,基本过程就是取原值低位赋值给目标值低位，然后原值右移一位，目标值左移一位，直到循环结束。 $$\r\\begin{array}{ll}\r\\hline\r\\text{\\textbf{Function}} \u0026 \\text{ReverseBits}(i, b) \\\\\r\\hline\r\u0026 result \\leftarrow 0 \\\\\r\u0026 \\text{for}\\quad j = 0\\quad\\text{to}\\quad b - 1 \\\\\r\u0026 \\quad result \\leftarrow result \\ll 1 \\\\\r\u0026 \\quad bit \\leftarrow (i \\gg j) \\\u0026 1 \\\\\r\u0026 \\quad result \\leftarrow result \\, | \\, bit \\\\\r\u0026 \\text{endfor} \\\\\r\u0026 \\text{return}\\quad result \\\\\r\\hline\r\\end{array}\r$$\r迭代算法实现 算法 3 是$DIT$实现，算法4是$DIF$实现。$s $ 可以看作是合并轮数。$m$ 是当前合并次数下每个单元的规模。其中$\\hat{1}$是乘法单位元都是$\\omega_n^0$。这里的$\\omega_n=﻿e^{\\pm2\\pi i / n}$,在进行$FFT$操作时取正，$I","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:1:3","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"1.4 快速数论变换（$NTT$） $FFT$ 存一些问题。首先 FFT 是在复数域上的表示，而计算机系统中表示复数，需要比实数花费更多的资源，且复数运算也比实数运算更加复杂。此外 FFT 涉及大量的正余弦运算，对于精度有影响。于是我们期望在实数域内寻找类似单位根性质的数学概念。有限域上的原根满足相应的要求。 1.4.1 数学基础 欧拉函数 欧拉函数，即 $\\varphi(n)$,表示的是小于等于 $n$ 且和 $n$ 互素的数的个数。当 n 是素数时 $\\varphi(n)=n-1$。 欧拉定理 对于 $a \\in \\Z$ ,$m\\in \\N^*$,若 $\\gcd(a,m)=1$,则 $a^{\\varphi(m)} \\equiv 1 \\pmod{m}$。 费马小定理 若 $p $ 为素数，$\\gcd(a,p)=1$,则 $a^{p-1} \\equiv 1 \\pmod{p}$。 也可表达为，对于任意整数 $a $，有 $a^p \\equiv a \\pmod{p}$。 利用费马小定理求逆元:$a^{-1}=a^{p-2}$ 阶 由欧拉定理可知，若 $\\gcd(a,p)=1$，一定存在一个最小的正整数 $n$ 满足同余式 $a^n \\equiv 1 \\pmod{m}$。这个 $n$ 被称作 $a$ 模 $m$ 的阶记作 $\\delta_m(a) $ 或者 $ord_m(a)$。具有以下性质： 性质 1：$a,a^2,\\ldots,a^{\\delta_m(a)}$ 模 $m $ 两两不同余，之后进入周期。 性质 2：若 $a^n \\equiv 1 \\pmod{m}$,则 $\\delta_m(a)|n$。可以推导出若 $a^p \\equiv a^q \\pmod{m} $，则有 $p \\equiv q \\pmod{\\delta_m(a)}$。 原根 给定 $n \\in \\N^*$ ，$g \\in \\Z$，满足 $\\gcd(g, m) = 1$，且 $\\delta_m(g) = \\varphi(m)$ ，则称 $g$ 为模 $m$ 的原根。 即 $g$ 满足 $\\delta_m(g)=| \\Z_m^* |=\\varphi(m)$ 。当 $m$ 是素数时，我们有 $g^i \\mod m$，$0\u003ci\u003cm$ 的结果互不相同 原根个数：若一个数 $m$ 有原根，则它原根的个数为 $\\varphi(\\varphi(m))$。 原根存在定理：一个数 $m$ 存在原根当且仅当 $m=2,4,p^a,2p^a$ ，其中 $p$ 为奇素数，$a\\in \\N^*$。 原根的性质 原根具有以下性质，不难看与单位根具有类似的性质。所以可以用于替代单位根，用于简化 $DFT$ 计算。 不重性：$\\forall 0 \\leq i \u003c j \u003c \\varphi(p),\\ g^i \\not\\equiv g^j \\pmod{p} $ 折半性：定义 $g_n = g^{\\frac{1}{n}} \\equiv g^{\\frac{p-1}{n}}$,$g_n^k = (g_n)^k$ 则 $g_{an}^{ak} \\equiv g_n^k \\pmod{p}$。 对称性：$g_{2n}^{k+n} \\equiv - g_{2n}^k \\pmod{p}$ 求和性：$\\sum_{i=0}^{n-1} (g_n)^{ki} \\equiv n[k=0] \\pmod{p} $，$k=0$ 为真 $[k=0]=1$,否则为 $0$。 原根与模数的选择 为了实现多次二分，模数 $p$ 应选可以拆分为 $q\\times 2^k +1$ 的素数,$q$ 为奇素数，$k$ 为整数,$2^k$ 模数的阶，也就是原根的最大数量。可以看下表的例子。 $$\r\\text{表 1：原根和模数的相关数据}\\\\\r\\begin{array}{cccc}\r\\hline\r\\text{原根 } g \u0026 \\text{模数 } p \u0026 \\text{分解 } p \u0026 \\text{模数的阶} \\\\\r\\hline\r3 \u0026 469762049 \u0026 7 \\times 2^{26} + 1 \u0026 2^{26} \\\\\r3 \u0026 998244353 \u0026 119 \\times 2^{23} + 1 \u0026 2^{23} \\\\\r3 \u0026 2281701377 \u0026 17 \\times 2^{27} + 1 \u0026 2^{27} \\\\\r\\hline\r\\end{array}\r$$\r1.4.2 $NTT$ 的递归实现 将原根带入公式（7）得： $$\r\\begin{align}\rP(g_n^k)=P_e((g_n^k)^2)+{g_n^k}P_o((g_n^k)^2)\\mod p \\quad k \\in[ 0,n)\r\\end{align}\r$$\r根据消去引理推导出得对称性以及折半引理对公式（13）进行化简。取 $k \\in[0,\\frac{n}{2})$ 。 $$\r\\begin{align*}\rP(g_{n}^{k})\u0026=P_{e}((g_{n}^{k})^2)+{g_{n}^{k}}P_{o}((g_{n}^{k})^2) \\mod p\\\\\r\u0026 =P_{e}(g_{\\frac{n}{2}}^{k})+{g_{n}^{k}}P_{o}(g_{\\frac{n}{2}}^{k}) \\mod p\\\\ \\end{align*}\r$$\r$$\r\\begin{align*}\rP(g_{n}^{k+m})\u0026=P_{e}((g_{n}^{k+m})^2)+g_{n}^{k+m}P_{o}((g_{n}^{k+m})^2) \\mod p\\\\\r\u0026 =P_{e}(g_{\\frac{n}{2}}^{k+m})+g_{n}^{k+m}P_{o}(g_{\\frac{n}{2}}^{k+m}) \\mod p\\\\ \u0026 =P_{e}(-g_{\\frac{n}{2}}^{k})-g_{n}^{k}P_{o}(-g_{\\frac{n}{2}}^{k}) \\mod p\\\\\r\u0026 =P_{e}(g_{\\frac{n}{2}}^{k})-g_{n}^{k}P_{o}(g_{\\frac{n}{2}}^{k}) \\mod p\r\\end{align*}\r$$\r简化为： $$\rP(g_{n}^{k})=P_{e}(g_{\\frac{n}{2}}^{k})+{g_{n}^{k}}P_{o}(g_{\\frac{n}{2}}^{k})\\\\\rP(g_{n}^{k+m})=P_{e}(g_{\\frac{n}{2}}^{k})-g_{n}^{k}P_{o}(g_{\\frac{n}{2}}^{k})\r$$\r现在给出递归版本得算法,不难发现除了将单位根替换为原根，增加模运算，以及增加了参数 ，原根 $g$，模数 $p $ 外与 $FFT$ 并无太大区别。 $$\r\\begin{array}{ll}\r\\hline\r\\text{\\textbf{Algorithm 5}} \u0026 \\text{ Recursion Number Theoretic Transform (NTT)}\\\\ \\hline\r\\textbf{Require:} \u0026 A=[a_0,a_1,\\ldots,a_{n-1}],\\quad n=2^{k},\\quad g ,\\quad p \\\\\r\\text{\\textbf{function}} \u0026 \\text{NTT\\_R}(A, g, p)\\\\ \u0026n\\leftarrow \\text{len}(A)\\\\\r\u0026\\text{if}\\quad n==1 \\\\\r\u0026\\quad \\text{return}\\quad A\\\\\r\u0026\\text{endif}\\\\\r\u0026g_n \\leftarrow g^{\\frac{p-1}{n}} \\pmod p\\\\\r\u0026A_e\\leftarrow [a_0,a_2,\\ldots,a_{n-2}]\\\\\r\u0026A_o\\leftarrow [a_1,a_3,\\ldots,a_{n-1}]\\\\\r\u0026Y_e\\leftarrow \\text{NTT\\_R}(A_e, g_n^2, p)\\\\\r\u0026Y_o\\leftarrow \\text{NTT\\_R}(A_o, g_n^2, p)\\\\\r\u0026 \\text{for} \\quad k \\quad \\text{from} \\quad 0 \\quad \\text{to} \\quad n/2-1\\\\\r\u0026\\quad Y[k]= (Y_e[k] + g_n^k Y_o[k]) \\pmod p\\\\\r\u0026\\quad Y[k+n/2]= (Y_e[k] - g_n^k Y_o[k]) \\pmod p\\\\\r\u0026\\text{end for}\\\\\r\u0026\\text{return} \\quad Y \\\\\r\\textbf{end function} \u0026 \\\\ \\hline \u0026 \\end{array}\r$$\r注意NTT里的$g^{-1}$是取逆元操作，在计算$INTT$时请注意。 1.4.3 $NTT$ 的迭代实现 $NTT$ 的迭代实现同理，因此不再赘述，直接给出相应的算法。 $$\r\\begin{array}{ll}\r\\hline\r\\text{\\textbf{Algorithm 6}} \u0026 \\text{Iteration NTT}\\\\ \\hline\r\\text{\\textbf{Require:}} \u0026 A=[a_0,a_1,\\ldots,a_{n-1}],\\ n=2^{k},\\quad g, \\quad p\\\\ \\text{\\textbf{function}} \u0026 \\text{NTT\\_I}(A, g, p)\\\\ \u0026 n \\leftarrow \\text{len}(A","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:1:4","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"1.5 矩阵DFT​算法 现在介绍另外一种算法，这种算法提高缓存命中率，从而提高执行效率。这种算法是将输入看作是一个行优先的矩阵进行计算，请注意对于NTT来说实际的输入指的是系数$a_i$。 如果 $n=R\\cdot C$ 我们可以用 $i_r\\in[0,R)$ 和 $i_c \\in [0,C)$ 重写$i=i_r\\cdot C+i_c$ 。这将创建一个对应 $[0,n) \\backsimeq[0,R) \\times[0,C)$。另一种对应关系是 $k=k_r+k_c\\cdot R$ ,注意这里输出的顺序已经变成了列优先了。将$i$和$k$带入下式。 $$\rP_{k}=P(\\omega_{n}^{k})=\\sum_{i=0}^{n-1}a_{i}\\omega_{n}^{ki}\\quad k=0,1,\\ldots,n-1\r$$\r需要提前明确的一点是这里公式中$\\omega$既可以是原根又可以是单位根,不过为了统一表示省去了原根的取模操作。替换可得： $$\r\\begin{align}P_{k_{r}+k_{c}\\cdot R}=\\sum_{i_{c}=0}^{C-1}\\sum_{i_{r}=0}^{R-1}a_{i_{r}\\cdot C+i_{c}}\\cdot\\omega_{R\\cdot C}^{(k_{r}+k_{c}\\cdot R)(i_{r}\\cdot C+i_{c})}\\end{align}\r$$\r将$\\omega$的幂次展开： $$\r\\begin{align*}\r\\omega_{R\\cdot C}^{(k_{r}+k_{c}\\cdot R)(i_{r}\\cdot C+i_{c})}\u0026=\\omega_{R\\cdot C}^{i_{c}k_{r}+i_{c}k_{c}\\cdot R+i_{r}k_{r}\\cdot C+i_{r}k_{c}\\cdot RC} \\\\\u0026=\\omega_{R\\cdot C}^{i_{c}k_{r}}\\cdot \\omega_{R\\cdot C}^{i_{c}k_{c}\\cdot R}\\cdot \\omega_{R\\cdot C}^{i_{r}k_{r}\\cdot C}\\cdot \\omega_{R\\cdot C}^{i_{r}k_{c}\\cdot RC}\r\\end{align*}\r$$\r根据原根的折半性质或者单位根的消去引理$\\omega_{an}^{ak}=\\omega_n^k$，可得： $$\r\\omega_{R\\cdot C}^{i_{c}k_{r}}\\cdot \\omega_{R\\cdot C}^{i_{c}k_{c}\\cdot R}\\cdot \\omega_{R\\cdot C}^{i_{r}k_{r}\\cdot C}\\cdot \\omega_{R\\cdot C}^{i_{r}k_{c}\\cdot RC}=\\omega_{n}^{i_{c}k_{r}}\\cdot \\omega_{C}^{i_{c}k_{c}}\\cdot \\omega_{R}^{i_{r}k_{r}}\\cdot1\r$$\r则公式(14)变为如下形式： $$\rP_{k_{r}+k_{c}\\cdot R}=\\sum_{i_{c}=0}^{C-1}\\sum_{i_{r}=0}^{R-1}a_{i_{r}\\cdot C+i_{c}}\\cdot \\omega_{n}^{i_{c}k_{r}}\\cdot \\omega_{C}^{i_{c}k_{c}}\\cdot \\omega_{R}^{i_{r}k_{r}}\r$$\r添加一些括号来确定运算顺序则变成了： $$\rP_{k_{r}+k_{c}\\cdot R}=\\sum_{i_{c}=0}^{C-1}\\Bigg[\\bigg(\\sum_{i_{r}=0}^{R-1}a_{i_{r}\\cdot C+i_{c}}\\cdot \\omega_{R}^{i_{r}k_{r}}\\bigg)\\omega_{n}^{i_{c}k_{r}} \\Bigg] \\omega_{C}^{i_{c}k_{c}}\r$$\r首先对输入a子序列进行长度为$R$的$DFT$操作，然后对结果乘上旋转因子，最后进行长度为$C$的$DFT$操作。这么看可能不直观，我们将输入写成一个$R \\times C$大小的矩阵： $$\ra\r=\r\\left[ \\begin{array}{ccccc}\ra_0 \u0026 a_1 \u0026 a_2 \u0026\\ldots \u0026 a_{C-1} \\\\\ra_C \u0026 a_{C+1} \u0026 a_{C+2} \u0026 \\ldots \u0026 a_{C+(C-1)} \\\\\ra_{2C} \u0026 a_{2C+1} \u0026 a_{2C+2} \u0026 \\ldots \u0026 a_{2C+(C-1)} \\\\\r\\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\ra_{(R-1)C} \u0026 a_{(R-1)C+1} \u0026 a_{(R-1)C+2}\u0026 \\ldots \u0026 a_{(R-1)C+(C-1)}\r\\end{array} \\right]\r$$\r先对对所有列进行DFT运算，然后所有元素乘上相应的转换因子，最后对所有行进行DFT运算。下面是转换转换因子矩阵$T$，注意转换因子矩阵与对列进行DFT的结果进行的是逐点相乘。因为输出是列优先排序，所以需要对结果进行一个转置，从而使得输入与输出保持同一顺序。 $$\rT=\\left[\\begin{array}{ccccc}\r1 \u0026 1 \u0026 1 \u0026 \\ldots \u0026 1\\\\\r1 \u0026 \\omega \u0026\\omega^2 \u0026 \\ldots \u0026 \\omega^{C-1}\\\\\r1 \u0026 \\omega ^2 \u0026 \\omega ^4 \u0026\\ldots \u0026 \\omega^{2(C-1)}\\\\\r\\vdots \u0026 \\vdots\u0026 \\vdots \u0026 \\ddots \u0026 \\vdots\\\\ 1 \u0026 \\omega^{R-1}\u0026\\omega^{2(R-1)} \u0026 \\ldots \u0026 \\omega^{(C-1)(R-1)}\r\\end{array}\\right]\r$$\rFour-step DFT 对上面的算法进行一个总结就是所谓的四步DFT算法,$[R \\times C]$，表示为大小为$R\\times C$的行优先矩阵。 $IDFT*$是省略乘上$n^{-1}$的$IDFT$，所以最后需要补上$n^{-1}$。 DFT: $[R \\times C]$,对每一列进行长度为$R$的$DFT$运算。 $[R \\times C]$,所有元素乘上对应的转换因子$\\omega^{ik}$。 $[R \\times C]$,对每一行进行长度为$C$的$DFT$运算。 $[R \\times C]$,将矩阵进行转置。 IDFT：* $[C \\times R]$,将矩阵进行转置。 $[R \\times C]$,对每一行进行长度为$C$的$IDFT*$运算。 $[R \\times C]$,所有元素乘上对应的转换因子$\\omega^{-ik}$。 $[R \\times C]$,对每一列进行长度为$R$的$IDFT*$运算。 Six-step DFT 对列进行操作，无法读取连续的内存会影响计算效率，可以增加转置操作，于是获得六步DFT算法： DFT: $[R \\times C]$,将矩阵进行转置。 $[C \\times R]$,对每一行进行长度为$R$的$DFT$运算。 $[C \\times R]$,将矩阵进行转置。 $[R \\times C]$,所有元素乘上对应的转换因子$\\omega^{ik}$。 $[R \\times C]$,对每一行进行长度为$C$的$DFT$运算。 $[R \\times C]$,将矩阵进行转置。 IDFT:* $[C \\times R]$,将矩阵进行转置。 $[R \\times C]$,对每一行进行长度为$C$的$IDFT*$运算。 $[R \\times C]$,所有元素乘上对应的转换因子$\\omega^{-ik}$。 $[R \\times C]$,将矩阵进行转置。 $[C \\times R]$,对每一行进行长度为$R$的$IDFT*$运算。 $[C \\times R]$,将矩阵进行转置。 ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:1:5","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"2 NTT 设计 本节主要是介绍对NTT的设计，例如模约简方案、转置优化以及预计算。最后探讨有哪些可以进行的优化。 ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:2:0","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"2.1 模约简 2.1.1 朴素方案 在模数约简的朴素方法中，如果硬件支持的话，会使用一个硬件指令将两个字（word）长度的被除数除以一个字长度的除数，得到一个字长度的商和一个字长度的余数。如果硬件不支持这种指令，那么就需要在软件中模拟这种指令。 这样的指令在x86和x86-64架构中是存在的。对于软件模拟，GNU GCC和Clang编译器在32位平台上提供了uint64_t类型，在64位平台上提供了unsigned __int128类型，并且这些类型都支持除法操作。 2.1.2 Barrett 约简 巴雷特约简的思路很简单，将计算$z =a \\mod p$，转换为$z=a- tp,t=\\lfloor ap^{-1}\\rfloor$ 。于是问题就从模运算转换为了求取$p^{-1}$的近似值,也就是$t$的近似值。 对$t$进行进行变换： $$\rt=\\lfloor \\frac{a}{p} \\rfloor=\\lfloor \\frac{\\frac{a}{b^{k-1}}\\frac{b^{2k}}{p}}{b^{k+1}} \\rfloor\r$$\r其中$b$是基底，计算机系统中通常使用二进制表示，即$b=2$，$k$是模数相对于基底的位宽$k=\\log_{b}p+1$，之所以是$b^{2k}$是因为通常运用模约简的场景是模乘，因此$a\\in[0,p^2)$。经过变换，我们发现分离出来一个一个仅和模数有关的量:$\\alpha = \\frac{b^{2k}}{p}$，这意味着对同一模数的约简可以提前计算$\\alpha$，其他部分可以通过右移和乘法完成，乘法运算效率显著高于除法运算，位移效率更快，计算速度提升了很多。 为了避免浮点数计算，令$\\beta=\\lfloor \\frac{b^{2k}}{p} \\rfloor$,替换掉$\\alpha$,得到$t$的近似$\\hat{t}$： $$\r\\hat{t}=\\lfloor \\frac{\\lfloor\\frac{a}{b^{k-1}}\\rfloor \\beta}{b^{k+1}} \\rfloor=\\lfloor \\frac{\\lfloor\\frac{a}{b^{k-1}}\\rfloor \\lfloor \\frac{b^{2k}}{p} \\rfloor}{b^{k+1}} \\rfloor\r$$\r现在考虑$t$与$\\hat{t}$的误差： $$\r\\lambda = \\frac{a}{b^{k-1}} - \\lfloor \\frac{a}{b^{k-1}} \\rfloor\r$$\r$$\r\\mu = \\frac{b^{2k}}{p} - \\lfloor \\frac{b^{2k}}{p} \\rfloor\r$$\r且$0 \\le \\lambda \\lt 1$,$0 \\le \\mu \\lt 1$，此外还有： $$\rt=\\lfloor\\frac{a}{b^{k-1}}\\cdot\\frac{b^{2k}}{p}\\cdot\\frac{1}{b^{k+1}}\\rfloor=\\lfloor\\frac{(\\lfloor\\frac{a}{b^{k-1}}\\rfloor+\\lambda)(\\lfloor\\frac{b^{2k}}{p}\\rfloor+\\mu)}{b^{k+1}}\\rfloor\\leq\\lfloor\\hat{t}+\\frac{\\lfloor\\frac{a}{b^{k-1}}\\rfloor+\\lfloor\\frac{b^{2k}}{p}\\rfloor+1}{b^{k+1}}\\rfloor\r$$\r因为$a\\lt b^{2k}$,所以$\\lfloor \\frac{a}{b^{k-1}} \\rfloor \\leq b^{k+1}-1$；又因为$p \\ge b^{k-1}$,所以$\\lfloor \\frac{b^{2k}}{p}\\rfloor \\leq b^{k+1}$。对上面不等式放缩： $$\rt\\leq\\lfloor\\hat{t}+\\frac{b^{k+1}-1+b^{k+1}+1}{b^{k+1}}\\rfloor=\\lfloor\\hat{t}+2\\rfloor\r$$\r又因为$\\hat{t} \\le t$,所以可得： $$\rt-2 \\le \\hat{t} \\le t\r$$\r近似性不错，进一步可得： $$\r0 \\lt a - \\hat{t}p \\le a - (t-2)p=a-tp+2p\r$$\r又因为$a-tp=z\\lt p$，所以： $$\r0 \\lt a - \\hat{t}p \\lt 3p\r$$\r不难看出使用近似方法得出得值有可能比p大，但是通过最多两次减法就可以修正误差，下面给出完整的算法： $$\r\\begin{array}{ll}\r\\hline\r\\text{\\textbf{Algorithm 7}} \u0026 \\text{Barrett 约简}\\\\ \\hline\r\\text{\\textbf{Require:}} \u0026 a\\quad \\beta=\\lfloor \\frac{b^{2k}}{p} \\rfloor\\quad p\\\\ \\text{\\textbf{function}} \u0026 Barrett(a,\\beta,p)\\\\ \u0026 \\hat{t} \\leftarrow \\lfloor \\frac{\\lfloor\\frac{a}{b^{k-1}}\\rfloor \\beta}{b^{k+1}} \\rfloor\\\\ \u0026 z_1 \\leftarrow a \\mod b^{k+1}\\\\\r\u0026 z_2 \\leftarrow \\hat{t}\\cdot p \\mod b^{k+1}\\\\\r\u0026 z=z_1-z_2\\\\\r\u0026 \\text{if} \\ z \\lt 0\\\\ \u0026 \\quad z=z+b^{k+1}\\\\\r\u0026 \\text{endif}\\\\ \u0026 \\text{while} \\ z \\ge p\\\\ \u0026 \\quad z=z-p\\\\\r\u0026 \\text{endwhile}\\\\ \u0026 \\text{return}\\ z\\\\\r\\text{\\textbf{end function}} \u0026 \\\\ \\hline\r\u0026 \\end{array}\r$$\r$z_1$和$z_2$的运算可以通过位与操作直接去掉k位的高位即可，简化了计算。下面给出$\\beta$的算法： $$\r\\begin{array}{ll}\r\\hline\r\\text{\\textbf{Algorithm 8}} \u0026 \\text{计算} \\beta\\\\ \\hline\r\\text{\\textbf{Require:}} \u0026 p\\quad k \\quad b\\\\ \\text{\\textbf{function}} \u0026 get\\beta(p,k,b)\\\\ \u0026 \\beta \\leftarrow b^k\\\\ \u0026 \\text{repeat} \\\\ \u0026 \\quad s \\leftarrow \\beta \\\\\r\u0026 \\quad \\beta \\leftarrow 2\\beta -\\lfloor\\frac{ p\\lfloor \\frac{\\beta^2}{b^k} \\rfloor }{b^k} \\rfloor\\\\\r\u0026 \\text{until} \\ \\beta \\le s \\\\ \u0026 t \\leftarrow b^{2k}-p\\beta\\\\\r\u0026 \\text{while} \\ t \\lt 0\\\\ \u0026 \\quad \\beta \\leftarrow \\beta -1\\\\ \u0026 \\quad t \\leftarrow t+p\\\\ \u0026 \\text{endwhile}\\\\ \u0026 \\text{return}\\ \\beta\\\\\r\\text{\\textbf{end function}} \\\\\r\\hline\r\u0026\\end{array}\r$$\r2.1.3 Montgomery 约简 蒙哥马利模乘约减的思路是通过变换，将需要取模的数控制到很小的范围（$[0,(p-1)^2] \\rightarrow [0,2p-1]$ ）然后通过少量减法获取最后结果。并通过位运算简化计算，例如：右移除法、位与取模。 蒙哥马利约简 对于$\\forall t \\in \\Z$且满足$a \u003c r p$，$r\\gt p$，$\\gcd(r,p)=1$ 。$p$是以$b$为基底,长度为$k$的整数，则r的取值为$b^k$，计算机中$b$为$2$，显然$r\\gt p$。但是只有当$\\gcd(b,p)=1$时才满足$\\gcd(r,p)=1$，之前提到的格式是满足条件的。 由于$r$和$p$互素，所以存在$r’,p’ \\in[0,p)$使得下式成立，$r’$是$r$在$p$下的逆元 ，$p’$是$p$在$r$下的负逆元。 $$\rrr'-pp'=1\r$$\r于是： $$\r\\begin{align*}\rar' \u0026=ar'\\frac{r}{r} \\\\\r\u0026=\\frac{arr'}{r} \\\\\r\u0026=\\frac{a(1+pp')}{r} \\\\\r\u0026=\\frac{a+app'}{r} \\\\\r\u0026=\\frac{a+(\\lfloor \\frac{ap'}{r} \\rfloor r+(ap' \\bmod r))p}{r} \\\\\r\u0026=\\frac{a+(ap' \\bmod r)p}{r}+\\lfloor \\frac{ap'}{r} \\rfloor p \\\\\r\u0026\\equiv \\frac{a+(ap' \\bmod r)p}{r} \u0026\\pmod{p} \\\\\r\u0026\\equiv \\frac{a+((a\\bmod r)p' \\mod r)p}{r} \u0026\\pmod{p} \\\\\r\\end{align*}\r$$\r其中$\\lfloor \\frac{ap’}{r} \\rfloor r+(ap’ \\bmod","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:2:1","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"2.2 root power 预计算 算法3中需要反复执行$\\varphi=\\varphi \\omega_m$，这里的m是当前合并轮次下每个单元的数据规模或者是蝶形运算的步长，$s $ 可以看作是当前合并轮数，$n$是输入规模，$l$是总的轮数。$\\omega_m=\\omega^{2^{n-s}}$,$s=\\log_2m$。一共具有两种预计算方案 方案一： 预计算$\\omega$的幂到一个root power表$t$中，即$t[i]=\\omega^i ,i\\in[0,\\frac{n}{2})$。对于给定的$j$和$m=2^s$，我们可以表示旋转因子$\\varphi =t[j\\cdot 2^{\\alpha }], \\alpha =n-s,j\\in [0,2^{s-1})$。 方案二： 计算每个粒度$s\\in[1,n]$,单独的root power表： $$\rT_s[i]=t[i\\cdot 2^{n-s}]=(\\omega^{2^{n-s}})^i, i\\in [0,2^{s-1})\r$$\r记$T_n=t$，$\\sum_{s=1}^n|T_s|=\\sum_{s=1}^n 2^{s-1}=2^n-1$。对于给定的$j$和$m=2^s$，我们可以表示旋转因子$\\varphi =T[j]$。然后我们将将所有的$T_s$组成一个大的表$T$。 $$\rT_s[i]=T[(2^0+2^1+2^2+ \\cdots +2^{s-2})+i]=T[2^{s-1}-1+i]\r$$\r对于给定的$j$和$m=2^s$，我们可以表示旋转因子$\\varphi =T[\\beta + j],\\beta=2^{s-1}-1=\\frac{m}{2}-1$。 两种方式$T[\\beta+j]$ 和$t[j \\cdot 2^\\alpha ]$，内层索引都是相同的，$\\alpha$ 和 $\\beta$表示循环中不变的表达式，在循环开始前计算一次。但是$T$，可以使用指针指向$T[\\beta]$, 一步解引用。而$t$需要先位移后解引用。 Four-step算法： 因为要用到所有的幂次，所以直接预计算所有的幂次，构建幂次表$T_*$即可。需要设计合适的索引。我的想法是利用折半引理，在对行或是对列的NTT中索引格式只需要在方案二的基础上进行细微改动即可，只需要乘上总规模$N$除当前NTT规模$n$的商即可，$T_*[(\\beta+j)\\frac{N}{n}]=T_*[\\beta \\mu+j\\mu]$,只是这种方法会使得方案本一步完成的解引用，需要两步而且增加的是开销较高的乘法。至于列运算结束后的旋转因子矩阵直接按照输入索引去查询即可，因为输入矩阵和旋转因子因子矩阵是一一对应的。 ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:2:2","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"2.3 转置优化 矩阵的转置有两种方式一种是out-place,一种是in-place。前者需要申请一块同等大小的空间，从而完成转置，即空间复杂度$O(R\\times C)$。后一种，空间复杂度远小于$O(R\\times C)$。这里主要讨论in-place转置方案，对于方阵很简单只需要交换$\u003ci,j\u003e$与$\u003cj,i\u003e$处的元素即可。 下面讨论$n\\times cn$形式的矩阵转置，为了方便表示不妨取$c=2$。将一个$n\\times 2n$的矩阵$M$拆分成两个$n\\times n$的方阵$A$和$B$: $$\rM=[A \\quad B]\r$$\r则转置表达为： $$\rM^T=[A \\quad B]^T=\r\\begin{bmatrix}\rA^T\\\\\\\rB^T\r\\end{bmatrix}\r$$\r定义$\\phi(M)$: $$\r\\phi(M)=[A^T\\quad B^T]\r$$\r现在将两个子矩阵$A^T$，$B^T$的行用向量表示： $$\r\\phi(M)=[A^T\\quad B^T]=\r\\begin{bmatrix}\r\\alpha_1 \u0026 \\beta_1\\\\\\\r\\cdots \u0026\\cdots \\\\\\\r\\alpha_n \u0026 \\beta_n\r\\end{bmatrix}\r\\longleftrightarrow\u003c\\alpha_1,\\beta_1,\\alpha_2,\\beta_2,\\cdots,\\alpha_n,\\beta_n \u003e\r$$\r$$\rM^T=\r\\begin{bmatrix}\rA^T\\\\\\\rB^T\r\\end{bmatrix}\r=\r\\begin{bmatrix}\r\\alpha_1 \\\\\\\r\\cdots \\\\\\\r\\alpha_n \\\\\\ \\beta_1 \\\\\\\r\\cdots\\\\\\ \\beta_n\r\\end{bmatrix}\r\\longleftrightarrow \u003c\\alpha_1,\\alpha_2,\\cdots,\\alpha_n,\\beta_1,\\beta_2,\\cdots,\\beta_n\u003e\r$$\r所以我们可以通过某种方法$\\rho$重新排列$\\phi(M)$的索引，使其等于$M^T=\\rho \\phi(M)$，对于索引$i$的目标位置$j$满足： $$\rj=\\rho (i)=n \\cdot (i \\bmod 2) + (i / 2) \\quad i\\in[0,2n)\r$$\r下面探究对于列排布能否实现同样的作用， 首先我们定义对方阵的行进行索引重排为$\\rho_r$,对其列进行索引成排为$\\rho_c$。很明显对于一个矩阵A,满足一下关系： $$\r(\\rho_cX)^T=\\rho_rX^T\r$$\r我们已经证明: $$\rM^T=\\rho_r \\phi(M)\r$$\r现在令$M=\\rho_c N$,即可获得： $$\r\\rho_r \\phi(\\rho_cN)=(\\rho_cN)^T\r$$\r$$\r\\rho_r \\phi(\\rho_cN)=\\rho_r(N)^T\r$$\r$$\r\\phi(\\rho_cN)=N^T\r$$\r现在证明对列进行排布同样可以完成相应的操作，只不过要现在哎方阵转置前进行列排布。对列进行排布对那内存更友好，需要$O(2n)$的额外空间。 对于$cn\\times n$形式的矩阵，只需要对列执行$\\rho^{-1}$然后对方阵转置就行。 ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:2:3","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"2.4 可能的优化 2.4.1 位逆序省略 我们回到最开始，我们引入DFT是为了进行多项式乘法： $$\rA(x)\\cdot B(x)=IDFT(DFT(A)\\cdot DFT(B))\r$$\r如果使用$DIF$完成$DFT$，使用$DIT$完成$IDFT$，我们就可以省略$DIF$最后的位逆序，以及$DIT$最开始的位逆序，紧挨着的两个位逆序可以省略。 2.4.2 省略转置 矩阵算法省略转置的原理与位逆序省略的原理相同，如果连续做$DFT$和$IDFT$，我们可以省略$DFT$最后的转置以及$IDFT$最开始的转置。\r2.4.3 合并 可以将对列之后乘旋转因子的操作合并到对列操作或者对行操作中，这样可以减少内存读写的次数。 对于$IDFT$可以将乘以$n^{-1}$,合并到四步$IDFT*$中，例如乘旋转因子的过程中。 ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:2:4","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["算法"],"content":"参考文献 [1]七海. 基础知识：FFT - 简单入门[EB/OL]//七海の参考書. (2021-03-29)[2024-01-21]. https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/. [2]快速数论变换（NTT）及蝴蝶操作构造详解[EB/OL]//知乎专栏. [2024-01-21]. https://zhuanlan.zhihu.com/p/80297169. [3]Frigo M, Leiserson C E, Prokop H, et al. Cache-oblivious algorithms[J]. ACM Transactions on Algorithms (TALG), 2012, 8(1): 1-22. https://doi.org/10.1145/2071379.2071383. [4]LESAVOUREY A, NEGRE C, PLANTARD T. Efficient Randomized Regular Modular Exponentiation using Combined Montgomery and Barrett Multiplications[C/OL]//ICETE: International Joint Conference on e-Business and Telecommunications: 4 [SECRYPT]. Lisbon, Portugal, 2016: 368-375[2024-02-28]. https://hal.science/hal-01330898. DOI:10.5220/0005998503680375. [5]Finite Field Implementations[Z/OL]. [2024-01-26]. https://docs.google.com/presentation/d/1I5QS58LtA3iiiPiVHHcN7oufCoo8sIDh9UvnJHWjA2Q. [6]RISC ZERO. Finite Field Implementations: Barrett \u0026 Montgomery[Z/OL]. (2023-02-17)[2024-01-26]. https://www.youtube.com/watch?v=hUl8ZB6hpUM. [7]AGARWAL R C, COOLEY J W. Fourier transform and convolution subroutines for the IBM 3090 Vector Facility[J/OL]. IBM Journal of Research and Development, 1986, 30(2): 145-161. DOI:10.1147/rd.302.0145. [8]董晓算法. G41 快速傅里叶变换 FFT算法 多项式乘法_哔哩哔哩_bilibili[EB/OL]. [2024-01-21]. https://www.bilibili.com/video/BV1Le4y1V78D/. [9]董晓算法. G43 快速数论变换 NTT算法_哔哩哔哩_bilibili[EB/OL]. [2024-01-21]. https://www.bilibili.com/video/BV1a3411Z7vL/. [10]HEIDEAN M, JOHNSON D, BURRUS C. Gauss and the history of the fast fourier transform[J/OL]. IEEE ASSP Magazine, 1984, 1(4): 14-21. DOI:10.1109/MASSP.1984.1162257. [11]COHEN H, FREY G, AVANZI R, 等. Handbook of Elliptic and Hyperelliptic Curve Cryptography[M/OL]. 0 版. Chapman and Hall/CRC, 2005[2024-02-26]. https://www.taylorfrancis.com/books/9781420034981. DOI:10.1201/9781420034981. [12]Hardcaml Zprize[EB/OL]. [2024-01-30]. https://zprize.hardcaml.com/ntt-top-level.html. [13]IEEE Xplore Full-Text PDF:[EB/OL]. [2024-02-28]. https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=\u0026arnumber=4176858. [14]Math \u0026 Engineering[EB/OL]. [2024-02-22]. https://xn–2-umb.com/. [15]LIANG Z, ZHAO Y. Number Theoretic Transform and Its Applications in Lattice-based Cryptosystems: A Survey[M/OL]. arXiv, 2022[2024-01-30]. http://arxiv.org/abs/2211.13546. [16]KNAUTH C, ADAS B, WHITFIELD D, 等. Practically efficient methods for performing bit-reversed permutation in C++11 on the x86-64 architecture[M/OL]. arXiv, 2017[2024-01-29]. http://arxiv.org/abs/1708.01873. [17]DUPAQUIS V, VENELLI A. Redundant Modular Reduction Algorithms[C/OL]//PROUFF E. Smart Card Research and Advanced Applications. Berlin, Heidelberg: Springer, 2011: 102-114. DOI:10.1007/978-3-642-27257-8_7. [18]Knezevic M, Vercauteren F, Verbauwhede I. Speeding up Barrett and Montgomery modular multiplications[J]. IEEE Transactions on Comput, 2009, 2.bar_mont.pdf (kuleuven.be) [19]KRAPIVENSKY V. Speeding up decimal multiplication[M/OL]. arXiv, 2020[2024-01-21]. http://arxiv.org/abs/2011.11524. DOI:10.48550/arXiv.2011.11524. [20]LONGA P, NAEHRIG M. Speeding up the Number Theoretic Transform for Faster Ideal Lattice-Based Cryptography[A/OL]. (2016)[2024-01-30]. https://eprint.iacr.org/2016/504. [21]REDUCIBLE. The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever?[Z/OL]. (2020-11-15)[2024-01-21]. https://www.youtube.com/watch?v=h7apO7q16V0. ‍ ‍ ","date":"2024-03-28","objectID":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html:3:0","tags":["基础","NTT"],"title":"NTT（快速数论变换）","uri":"/ntt%E5%BF%AB%E9%80%9F%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2.html"},{"categories":["CUDA"],"content":"1 GPU简单介绍 GPU(Graphics Processing Unit)也叫做图形处理单元，是一种专用电子电路，最初设计使用来加速计算机图形处理，但后续因其并行结构非常适合与并行计算领域。GPU一共经历了三个历史发展阶段。下面是显卡示意图，主要由GPU和显存组成。\rGPU示意图\r","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:1:0","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"1.1 GPU的发展阶段 1.1.1 硬件加速阶段 在1999年以前，将CPU的部分功能剥离出来，形成单独的硬件，实现对图像的硬件加速，只起到3D图像处理的加速作用，不具备软件编程特征。 1.1.2有限编程阶段 1999-2005年，进一步的硬件加速，但是出现了有限编程性。 1999年，Nvidia发布了专为执行复杂的数学和几何计算的GeForce256图像处理芯片，不同于CPU将晶体管主要用作控制单元和缓存，更多的作为执行单元,将图形变换以及照明等功能从CPU剥离出来，通过变换引擎和照明引擎实现了图形的快速变换以及光照计算，成为GPU出现的标志。 2000-2005，GPU技术快速发展，运算速度迅速超过GPU。Nvidia和ATI（被AMD收购）分别推出的GeForce3和Radeon 8500 ,出现顶点可编程性和像素级可编程性，但是总体上编程性十分有限。 1.1.3 软件可编程阶段 2006年，Nvidia和ATI分别推出了CUDA（Compute United Device Architecture)和CTM（Close To Metal)编程环境，使得GPU打破图形语言的局限成为真正的额并行数据处理超级加速器。 2008年，苹果提出通用的并行计算编程平台OpenCL,与具体平台无关，迅速成为移动端GPU的编程环境业界标准。\rNvidia软件生态.png\r","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:2:0","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"1.2 GPU工作原理 1.2.1基本概念解释 GPU的设计目标是最大化吞吐量（Throughout）和并行度（Parallelism）。而CPU更关心延迟（Latency）和并发（concurrency）。于是GPU采用了SIMT架构，单核CPU通常采用SIMD架构，多核CPU则通常采用MIMD架构。 CPU旨在以尽可能快的速度执行线程，并且可以并行执行几十个这些线程。而GPU试图通过并行执行数千个线程从而分摊时延以实现更高的吞吐量。 GPU专门用于高度并行计算，因此设计时更多的晶体管用于数据处理而不是数据缓存和流程控制。 多核CPU和GPU\r​​吞吐量： 单位时间内能够完成的操作。 延迟： 完成单项任务所消耗的时间。 并行： 同时处理多个任务，任务之间存在干扰。 并发： 一段时间内处理多个任务，任务之间可能互相干扰。 SIMD： SIMD(单指令多数据流)是从SISD（单指令单数据流）发展出来的。想要执行并行需要通过堆叠多个核心从而实现并行，每个核心执行一个线程，即MIMD（多指令多数据流）。而SIMD的想法是通过给每个核心中增加计算单元和寄存器，减少硬件开销。然后增加指令的操作数个数，使得一条指令可以驱动多个计算元件同时执行多个数据运算。 SIMT： SIMD看起来很好，但是对于高级语言的支持并不好。SIMT（单指令多线程）从本质上还是一套控制单元带多个计算单元，但是从一条指令控制多个计算单元和寄存器，变为将一条指令分发给多组计算单元和寄存器，从而优化高级语言的支持。 1.2.2 缓存机制 CPU中的缓存是为了存储下一步要计算的数据，从而减少访问数据的时延，提高线程的执行速度，从而实现高并发。而在GPU中缓存是为Thread提供服务的，缓存会合并线程相同的数据访问，让后从DRAM中访问数据，分发给线程。 A100 内存示意图\r​​SM(Streaming Multiprocessor) ：SM是是GPU的主要计算单元，负责执行并行计算任务。每个SM都包含多个流多处理器（CUDA核心），可以同时执行多个线程块中的指令。SM通过分配线程、调度指令和管理内存等操作，实现高效的并行计算。 HBM： 高带宽内存，也就是显存。它通过将内存芯片直接堆叠在逻辑芯片上，提供了极高的带宽和更低的能耗，从而实现了高密度和高带宽的数据传输。 L1 Cache/SMEM：L1 Cache包含指令缓存(Instruction Cache)和数据缓存（Data Cache），在SM内部存储最常用的指令和数据，每个SM独享一个L1 Cache，提供低延迟和高带宽的访问。 Register File: 用于存储临时数据、计算中间结果和变量。离计算单元最近，访问速度非常快。 带宽（BandWidth）： 单位时间内传输的数据量，主要有内存频率（Memory Data Rate）以及位宽（Memory Interface）决定的。例如A100的位宽是5210bit，频率是1215MHz,所以带宽为$\\frac{(\\frac{5210}{8}\\times1215\\times10^6\\times2)}{10^{9}}=1555GB/s$,乘2是因为DDR技术每个时钟周期传输两次数据，计算存储和传输时进制是$10^3$。 计算强度： 计算时间/内存读取时间。存储带宽越小计算强度应该越高，从而提高效率。 1.2.3 线程机制： Warp： 线程束。逻辑上，所有Thread是并行；但是，从硬件的角度来说，并不是所有的 Thread能够在同一时刻执行，这里就需要Warp的引入。 Warp 是 SM 基本执行单元，一个 Warp 包含32个并行 Thread，这32个 Thread 执行于 SIMT模式。也就是说所有 Thread 以锁步的方式执行同一条指令，但每个 Thread 会使用各自的 Data 执行指令分支。如果在 Warp 中没有32个 Thread 需要工作，那么 Warp 虽然还是作为一个整体运行，但这部分 Thread 是处于非激活状态的 ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:2:1","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"2 Nvidia GPU 介绍 ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:3:0","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"2.1 基础概念 2.1.1 CUDA线程层次结构 在A100的线程层次中由三层构成，grid（网格）、block（线程块）、thread（线程）。但是在H100中有引入了新的一层Cluster（簇）这里暂且不管。 这里姑且将在GPU上的任务称为kernel，一个kernel所调用的所有线程组成了grid。网格又可以拆分成拥有相同线程数的block。 Grid： 同一个网格上的线程共享相同的全局内存空间。grid是线程结构的第一层次。对应于GPU设备device。 Block： Block 间并行执行，并且无法通信，==没有执行顺序==，每个 block 包含共享内存（Shared Memory），可以里面的 Thread 共享。对应由于SM，A100中一个block包含2048个thread。 Thread： 同一个 block 中 thread 可以同步，也可以通过 Shared memory 通信,对应于cuda core。 Grid-Block-Thread\r2.1.2 CUDA 内存层次结构 CUDA 内存层次\r存储结构示意\r寄存器(Register)： 寄存器对于每个线程来说都是私有的，一个核函数通常使用寄存器来保存需要频繁访问的线程私有变量。寄存器变量与核函数的生命周期相同。一旦核函数执行完毕，就不能对寄存器变量进行访问了。 局部内存(Local Memory)： 局部内存是私有的，只有本线程才能进行读写访问。主要存储超出寄存器存储上线的数据，以及编译器无法静态确定的数据，局部内存在HBM上。 共享内存(Shared Memory)： 一个块可以被同一block中的所有线程访问的可读写存储器。访问共享存储器的速度几乎和访问寄存器一样快。是实现线程间通信的延迟最小的方法。 常量内存(Constant Memory)： 常量内存（const memory）是只读全局内存，在HBM中，但是其中的数据可以缓存在SM内部的常量缓存中（const cache）只。 纹理内存(Texture Memory)： 纹理内存类似于常量缓存，也是一种具有缓存的只读全局内存，与常量内存具有相同的生命周期和作用范围。纹理内存通常比常量内存要大，适合实现图像处理和查找表等操作。 全局内存(Global Memory)： 全局内存由于存放在HBM上，是GPU中容量最大、延迟最高的内存，主要作用是给核函数提供数据。GPU内核的所有线程都能对全局内存进行访问，但是访存的开销很大。 2.1.4 计算性能 $$\r𝑃𝑒𝑎𝑘 \\ 𝐹𝐿𝑂𝑃𝑆=𝐹_{𝑐𝑙𝑘}∗𝑁_{𝑆𝑀}∗𝐹_{𝑟𝑒𝑞}\r$$\r$F_{clk}$：为 GPU 时钟周期内指令执行数 (FLOPS/Cycle)。 $N_{SM}$：为 GPU SM 数量 (Cores)。 $F_{req}$：为运行频率 (GHz)。 ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:3:1","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"2.2 Nvidia架构 ​ 注意同同一架构不同型号的GPU存在差异。 2.2.1 Fermi 费米架构 Fermi 架构\r​ 首先从总体角度进行分析：GPU通过HostInterface，接收来自主机的指令与数据。使用一个Giga Thread Engine来管理所有正在进行的工作。GPU被划分成多个Graphics Processing Cluster（图形处理簇），每个GPC拥有多个SM和一个Raster Engine(光栅化引擎)。它们其中有很多的连接，最显著的是Crossbar，它可以实现GPC之间的通信并来连接其它功能性模块（例如ROP或其他子系统）。 Raster Engine：主要负责将图形管线中的矢量图形数据（如顶点）转换为像素信息（光栅图像）的部分。 ROP（Raster Operations Pipeline）：光栅操作单元，负责将光栅化引擎生成的像素数据进行最终处理，并将处理后的像素输出到帧缓冲区中，最终生成可在显示设备上显示的图像。 Fermi SM\r‍ 32 个 CUDA Core（分在两条 lane 上，每条分别是 16 个）, 每个 CUDA Core 里面是 1 个单精浮点单元（FPU）和 1 个整数单元（ALU）。 每个 cycle 可以跑 16 个双精的 FMA SM：从 G80 提出的概念，中文称流式多处理器，核心组件包括CUDA核心、共享内存、寄存器等。SM包含许多为线程执行数学运算的Core，是 NVIDA 的核心。 CUDA Core：向量运行单元 SP（Streaming processor）：流式处理器最基本的处理单元，Fermi 架构后，SP被改称为CUDA Core，最后线程具体的指令和任务都是在SP上处理的。GPU进行并行计算，也就是很多个SP同时做处理。一个SP对应一个线程。 FP32-FPU：单精度浮点数运算单元 FP64-DPU：双精度浮点数运算单元 INT32-ALU：整数运算单元 Special Function Units：特殊函数单元 SFU，计算超越函数和数学函数，例如余弦函数，但是存在精度损失。 Warp Scheduler：线程束调度器，用于将一批批的Warp发送给特定的计算核心SP执行计算。一个Warp由32个线程组成。 Dispatch Unit：指令分发单元，Dispatch Units负责将Warp Scheduler的指令送往Core执行（也就是上面的SP）。 Load/Store：加载/存储模块。辅助一个Warp（线程组）从Share Memory或显存加载(Load)或存储(Store)数据。这个单元处理操作都是异步的，也就是说其他单元在高速处理指令的时候，如果需要加载或者写回数据，则不会在这里等待LD/ST返回数据，而是跳转执行其他指令，待LD/ST把数据取到或者写回之后，再继续执行需要这些数据的后续指令。 Tex Unit：纹理(texture)读取单元,texture指通常理解的1D/2D/3D结构数据，相邻数据之间存在一定关系，或者相邻数据之间需要进行相同的运算。在一个运算周期最多可取4个采样器，这时刚好喂给一个线程束，每个Texture Uint有16K的Texture Cache，并且在往下有L2 Cache的支持。 PolyMorph Engine： 负责属性装配（attribute Setup）、顶点拉取（Vertex Fetch）、曲面细分、栅格化（这个模块可以理解专门处理顶点相关的东西） Vertex Fetch模块：顶点处理前期的通过三角形索引取出三角形数据。 Tesselator模块：对应着DX11引入的新特性曲面细分。 Stream Output模块：对应着DX10引入的新特性Stream Output。 Viewport Transform模块：对应着顶点的视口变换，三角形会被裁剪准备栅格化。 Attribute Setup模块：负责顶点的插值运算并输出给后续像素处理阶段使用。 Instruction Cache：指令缓存。存放将要执行的指令，通过Dispatch Units填装到每个运算核心（Core）进行运算。 Uniform Cache：用于提高对uniform变量访问的效率。Uniform变量是在着色器程序中使用的常量，它们对于一个渲染调用中的所有顶点或片元是相同的。这些变量包括但不限于矩阵（用于变换或投影）、光照参数、或者其他在着色器执行期间不会改变的全局状态信息。后续演化为constant cache。 Interconnect Network：是一个关键组件，它负责处理GPU内部各个部分之间的数据传输和通信。这个网络使得多个处理核心（CUDA核心）、内存控制器、缓存系统等可以高效地交换数据，从而提高整体的处理速度和效率。 2.2.2 Kepler 开普勒架构 Kepler架构\rKepler SMX\r相较于Fermi架构的变化不大。 SM改名成了SMX，但是所代表的概念没有大变化； 单个SMX的Cuda Core数量从32个增加到了192个（$4\\times3\\times16$），很奇怪的数字。 Kepler架构在硬件上直接有双精运算单元的架构； 提出 GPU Direct 技术，可以绕过 CPU/System Memory，完成与本机其他 GPU 或者其他机器 GPU 的直接数据交换。 2.2.3 Maxwell 麦克斯韦架构 Maxwell 电路示意图\rMaxwell架构\rMaxwll SMM示意图\rKepler架构的SMX过于庞杂，因此Maxwwll 的SMM砍掉了很多元件，将类似于Fermi架构的四个SM（Process Block）拼成了一个SMM。 2.2.4 Pascal 帕斯卡架构 Pascal架构\rPascal SM\r​ 单个SM只有64个FP32 CUDA Cores，相比Maxwell的128和Kepler的192，这个数量要少很多，并且64个CUDA Cores分为了两个区块； Register File 保持相同大小，每个线程可以使用更多寄存器，单个SM也可以并发更多 thread/warp/block； 增加 32个FP64 CUDA Cores (DP Unit)，FP32 CUDA Core 具备处理FP16的能力。 出现了TPC层次 引入了NVLink 2.2.5 Volta 伏特架构 Volta 架构\rVolta SM\r最显著的变化就是cuda core被拆分，整形计算单元和FP32计算单元独立出现在流水线中。可以在一个时钟周期内同时执行整形计算和单精度浮点数运算。同时相对于Pascal每个区块又被一分为二。不难看出在减小每个区块以及每个SM运算单元的数量，同时增加SM的数量。 最重要的是引入了张量核心(Tensor Core)。 2.2.6 Turing 图灵架构 Turing 架构\rTuring SM\r除了在Tensor Core中引入int 8 和int4，以及砍掉FP64单元外变动不大，主要集中在渲染管线和新加的这个 RT Core 光线追踪能力上。 2.2.7 Ampere 安培架构 Ampere 架构图\rAmpere SM结构\r增加了FP64单元，Tensor Core变为原来的一半，但是计算能力其实增强了，单个时钟周期吞吐量量提高了，同时引入了结构化稀疏能力。增加了多实例GPU（Multi-Instance GPU），将单个A100GPU划分为多达七个独立GPU，为不同任务提供不同算力。 引入了TF32 和BF16的支持： 2.2.8 Hopper 赫柏架构 Hopper 架构\rHopper SM\r​SM 结构： 4 个 Warp Scheduler，4 个 Dispatch Unit（与 A100 一致） 128 个 FP32 Core（4 * 32）（相比 A100 翻倍） 64 个 INT32 Core（4 * 16）（与 A100 一致） 64 个 FP64 Core（4 * 16）（相比 A100 翻倍） 4 个 TensorCore（4 * 1） 32 个 LD/ST Unit（4 * 8）（与 A100 一致） 16 个 SFU（4 * 4）（与 A100 一致） 相比 A100 增加了一个 Tensor Memory Accelerator Process Block： 1 个 Warp Scheduler，1 个 Dispatch Unit（与 A100 一致） 32 个 FP32 Core（相比 A100 翻倍） 16 个 INT32 Core（与 A100 一致） 16 个 FP64 Core（相比 A100 翻倍） 1 个 TensorCore 8 个 LD/ST Unit（与 A100 一致） 4 个 SFU（与 A100 一致） 引入了线程块簇，簇是一组保证可以并发调度的线程块，支持跨多个 SM 的线程进行高效协作和数据共享。簇还可以更高效地协同驱动Tensor 内存加速器和 Tensor Core 等异步单元。在物理层次上对应的是GPC,可以直接访问同簇内其他SM的共享内存而不用经过显存中转。 线程层次\r​ ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:3:2","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"2.3 TensorCore 矩阵乘法在进行行列相乘时需要逐元素的相乘累加。这个过程可以使用乘积累加指令FMA（Fused Multiply–accumulate operation）完成。 所谓的FMA指令就是：$a=a+(b\\times c)$下图示例需要$5\\times 5\\times 5$次FMA 完成。 矩阵乘法\r每个 Tensor Core 每周期能执行 $4\\times4\\times4$ GEMM，64 个 FMA。执行运算 D=AB+C，其中A、B、C 和 D是$4\\times4$ 矩阵。矩阵乘法输入 A 和 B 是 FP16 矩阵，而累加矩阵 C 和 D 可以是 FP16或 FP32 矩阵。 ​ Tensor Core执行融合乘法加法，其中两个$4\\times4$FP16矩阵相乘，然后将结果添加到$4\\times4$ FP16或FP32矩阵中，最终输出新的$4\\times4$ FP16或FP32矩阵。 每个 Tensor Core 每个时钟执行 64 个 FP32 FMA 混合精度运算，SM中8个 Tensor Core，每个时钟周期内总共执行 512 个浮点运算。 因此在 AI 应用中， Volta V100 GPU的吞吐量与Pascal P100 GPU相比，每个 SM 的 AI 吞吐量增加了 8 倍，总共增加了12倍。 ​ ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:3:3","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"2.4 NVlink NVLink：英伟达（NVIDIA）开发并推出的一种总线及其通信协议。NVLink采用点对点结构、串列传输，用于中央处理器（CPU）与图形处理器（GPU）之间的连接，也可用于多个图形处理器（GPU）之间的相互连接。 NVSwitch：是一种高速互连技术，同时作为一块独立的 NVLink 芯片，其提供了高达18路 NVLink 的接口，可以在多个 GPU 之间实现高速数据传输。 NCCL / HCCL： GPU/NPU 通信优化库，支持集中式通信。 ‍ ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:3:4","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["CUDA"],"content":"资料来源 [1] chenzomi12/DeepLearningSystem: Deep Learning System core principles introduction. (github.com) [2]TransformAndLighting.pdf (nvidia.com) [3] 深入GPU硬件架构及运行机制 - 0向往0 - 博客园 (cnblogs.com) [4]NVIDIA GPU性能优化基础 - 知乎 (zhihu.com) [5]1509.02308.pdf (arxiv.org) [6] Life of a triangle - NVIDIA's logical pipeline | NVIDIA Developer [7] GPU架构和渲染 - 知乎 (zhihu.com) [8]NVIDIA GPU 架构演进 | Chenfan Blog (jcf94.com) ‍ ","date":"2024-03-28","objectID":"/%E8%AE%A4%E8%AF%86gpu.html:4:0","tags":["基础","GPU 架构"],"title":"认识GPU","uri":"/%E8%AE%A4%E8%AF%86gpu.html"},{"categories":["技能"],"content":"1 准备阶段 ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:1:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"1.1 安装hugo 这里为了省去环境路径的配置采用如下的cmd命令方式，也可以选择去github下载相应文件。如文档：Hugo中文文档 (gohugo.org) winget install Hugo.Hugo.Extended ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:1:1","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"1.2 安装git Git - Downloads (git-scm.com) 选择合适的版本一直下一步即可。 在使用git前需要设置一下用户名和邮箱。 git config --global user.name \"username\" git config --global user.email useremail@qq.com ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:1:2","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"1.3 创建Github仓库 需要创建两个仓库一个公开仓库名字是username.github.io，名字必须是这个格式。另外创建一个私有仓库，是为了方便管理源代码。 ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:1:3","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"2 创建 site 参考：Quick start | Hugo (gohugo.io) 创建一个site hugo new site WebSite cd WebSite 初始化git仓库 git init git add . git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/CATSLAB-SDU/WebSite.git git push -u origin main 模板设置，可以更换自己喜欢的模板Complete List | Hugo Themes (gohugo.io) git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 修改hugo.toml文件，建议使用vscode baseURL = \"https://CATSLAB-SDU.github.io/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" uglyURLs=true # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"CATS LAB\" email = \"catslabsdu@gmail.com\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"笔记\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"笔记\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"标签\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"分类\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"light\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"sha256\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"CATS LAB\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description= \"实验室学习资料共享博客\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"/favicon.ico\" # 标题名称 name = \"CATS LAB\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2024 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"CATS LAB\" # 是否隐藏网站图标资源链接 noFavicon = true # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"favicon-32x32.png\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"CATSLAB\" appID = \"9DJIN648JY\" searchKey = \"e0475938b166cc32e8e52c7b0c3e6071\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"CATS LAB\" # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \"\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"内容为体系结构与隐私计算实验室学习资料分享，仅供参考，侵权请联系删除。\" # 主页文章列","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:2:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"3 部署到Github 进入pubilc创建仓库,并推送到公开仓库 cd public git init git add . git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/CATSLAB-SDU/CATSLAB-SDU.github.io.git git push -u origin main 在github中进行配置 ​ ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:3:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"4 自动部署 在站点根目录执行 Hugo​ 命令生成最终页面，注意替换仓库和主题。 hugo --theme=LoveIt --baseURL=\"https://CATSLAB-SDU.github.io/\" 在本地创建文件hugo.yaml mkdir .github/workflows/ new-item .github/workflows/main.yaml -type file 把下面内容复制到main.yaml中 # Sample workflow for building and deploying a Hugo site to GitHub Pages # This is a basic workflow to help you get started with Actions name: CI # Controls when the action will run. on: # Triggers the workflow on push or pull request events but only for the master branch push: branches: [main] pull_request: branches: [main] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB\\_WORKSPACE, so your job can access it - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Hugo setup # You may pin to the exact commit or the version. # uses: peaceiris/actions-hugo@2e89aa66d0093e4cd14751b3028fc1a179452c2e uses: peaceiris/actions-hugo@v2.4.13 with: # The Hugo version to download (if necessary) and use. Example: 0.58.2 hugo-version: latest # optional, default is latest # Download (if necessary) and use Hugo extended version. Example: true extended: true # optional, default is false - name: Build run: hugo - name: Pushes to another repository uses: cpina/github-action-push-to-another-repository@main env: API\\_TOKEN\\_GITHUB: ${{ secrets.API_TOKEN_GITHUB }} with: source-directory: \"public\" destination-github-username: \"CATSLAB-SDU\" destination-repository-name: \"CATSLAB-SDU.github.io\" user-email: catslabsdu@gmail.com 在github中设置Developer settings/Personal access tokens​，新建一个密钥，权限设置把Repo​打勾。 ​ 回到私人仓库的设置里，新建密钥，将刚才生成的个人密钥填进去，名字设为API_TOKEN_GITHUB​(跟 CI 脚本里的名称对应即可) ​ 完成该设置后更新私有库后公共库会自动更新。 ‍ ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:4:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"4 细节设置 Favicon Generator for perfect icons on all browsers (realfavicongenerator.net)利用该网站生成头像等资源发在static目录下面。 ‍ ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:5:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"5 评论设置 首先要去Github -\u003e Settings -\u003e Developer Settings -\u003e OAuth App​ 里注册一个新的 OAuth App 来给 Gitalk 使用。并修改config.toml: [params.page.comment] enable = true \u003c-- 启用评论系统 [params.page.comment.gitalk] enable = true owner = \"JellyZhang\" \u003c-- Github用户名 repo = \"blog-comment\" \u003c-- 用来存放评论的repo名称 clientId = \"\" \u003c-- 申请好的OAuth的ClientId clientSecret = \"\" \u003c-- 申请好的OAuth的ClientSecret ​ ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:6:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"6 搜索设置 在AI search that understands | Algolia创建账号,创建一个application​与index: ​ 然后将下面的内容填写到config.toml​中： # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"blog\" appID = \"9DJIN648JY\" searchKey = \"e0475938b166cc32e8e52c7b0c3e6071\" ​ ‍ 修改main.yaml，将下面内容加到最后面： - name: Algolia Index Uploader # You may pin to the exact commit or the version. # uses: rxrw/algolia-index-uploader@294d1d600c4a2197a64903b6161cc80acea1becb uses: rxrw/algolia-index-uploader@v1 with: # Your Algolia IndexPath index_path: public/index.json # Algolia Index Id algolia_index_id: 9DJIN648JY # Algolia Index Name algolia_index_name: CATSLAB # Algolia Admin Key algolia_index_admin_key: d4f23d91632cfbe0eeb5b9a6debbe280 ‍ ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:7:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"7 日常维护 登录github账号： user：catslabsdu@gmail.com password：catlab200. 在website仓库加入添加自己的github为协作账号，并在自己github账号绑定的邮件中同意。 ​ ‍ clone website仓库，将相应的markdown文件放到content/posts目录下，在文件前面加入，修改markdown.py中的文件名，执行python脚本进行字符转义。 +++ title = \"title\" date = \"2024-03-06T16:02:29+08:00\" draft = false subtitle = \"\" tags = [\"笔记1\",\"笔记1\"] categories = [\"方向\"] license = '\u003ca rel=\"license external nofollow noopener noreferrer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' +++ python转义主要是为了兼容数学公式,下面是一个示​例$idf*$​： $$\r\\begin{align*}\r\\omega_{R\\cdot C}^{(k_{r}+k_{c}\\cdot R)(i_{r}\\cdot C+i_{c})}\u0026=\\omega_{R\\cdot C}^{i_{c}k_{r}+i_{c}k_{c}\\cdot R+i_{r}k_{r}\\cdot C+i_{r}k_{c}\\cdot RC} \\\\\u0026=\\omega_{R\\cdot C}^{i_{c}k_{r}}\\cdot \\omega_{R\\cdot C}^{i_{c}k_{c}\\cdot R}\\cdot \\omega_{R\\cdot C}^{i_{r}k_{r}\\cdot C}\\cdot \\omega_{R\\cdot C}^{i_{r}k_{c}\\cdot RC}\r\\end{align*}\r$$\r返回website根目录执行： hugo git add . git commit -m \"添加文件\" git push -u origin main ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:8:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"},{"categories":["技能"],"content":"8 图片处理 markdown中的图片需要上传到网络图床。下载PicGo这里推荐山东大学的镜像网站：v2.3.1 (sdu.edu.cn) 进行图床设置： 仓库名: CATSLAB-SDU/ImageBed 分支：main token：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 存储路径： 自定义域名：https://cdn.jsdelivr.net/gh/CATSLAB-SDU/ImageBed@main ​ ","date":"2024-03-27","objectID":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html:9:0","tags":["网站"],"title":"Hugo+Github搭建个人主页","uri":"/hugo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5.html"}]